generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id               String         @id @default(uuid())
  username         String         @unique
  firstName        String
  lastName         String
  email            String         @unique
  password         String         // Password will be hashed
  description      String?
  avatarUrl        String?
  
  // Relations
  team             Team?          @relation(fields: [teamId], references: [id])
  teamId           String?
  
  // Posts et contenus
  posts            RegularPost[]
  notifications    Notification[]
  sentMessages     Message[]      @relation("SenderMessages")
  receivedMessages Message[]      @relation("ReceiverMessages")
  
  // Système de follow
  followedBy       Follow[]       @relation("Follower")
  following        Follow[]       @relation("Following")
  
  // Follow teams
  teamFollows      TeamFollow[]

  // Feed
  feed             FeedItem[]

  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
}

model Team {
  id           String       @id @default(uuid())
  teamname     String       @unique
  ceoFirstName String
  ceoLastName  String
  email        String       @unique
  password     String
  description  String?
  rosterList   Json?
  teamColor    String
  logoUrl      String?
  
  // Relations
  members      User[]
  offerPosts   OfferPost[]
  
  // Followers
  followers    TeamFollow[]

  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

// Relation many-to-many entre utilisateurs (follow)
model Follow {
  id          String   @id @default(uuid())
  
  follower    User     @relation("Following", fields: [followerId], references: [id], onDelete: Cascade)
  followerId  String
  
  followed    User     @relation("Follower", fields: [followedId], references: [id], onDelete: Cascade)
  followedId  String
  
  createdAt   DateTime @default(now())
  
  @@unique([followerId, followedId])
}

// Relation many-to-many entre utilisateurs et équipes
model TeamFollow {
  id        String   @id @default(uuid())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId    String
  
  createdAt DateTime @default(now())
  
  @@unique([userId, teamId])
}

// Feed
model FeedItem {
  id            String   @id @default(uuid())
  
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  
  contentType   String
  contentId     String
  
  isRead        Boolean  @default(false)
  createdAt     DateTime @default(now())
  
  @@index([userId, createdAt(sort: Desc)])
}

model RegularPost {
  id          String   @id @default(uuid())
  title       String
  description String
  imageList   Json?
  likes       Int      @default(0)
  likesList   Json?
  reposts     Int      @default(0)
  repostsList Json?
  comments    Json?
  
  poster      User     @relation(fields: [posterId], references: [id], onDelete: Cascade)
  posterId    String

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model OfferPost {
  id               String    @id @default(uuid())
  title            String
  description      String
  imageList        Json?
  applyingUserList Json?
  
  team             Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId           String
  
  messages         Message[]

  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
}

model Notification {
model Notification {
  id               String   @id @default(uuid())

  createdAt        DateTime @default(now())
}

model Message {
  id          String     @id @default(uuid())
  content     String
  
  sender      User       @relation("SenderMessages", fields: [senderId], references: [id], onDelete: Cascade)
  senderId    String
  
  receiver    User       @relation("ReceiverMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId  String
  
  offerPost   OfferPost? @relation(fields: [offerPostId], references: [id])
  offerPostId String?
  
  createdAt   DateTime   @default(now())
}

model FastSearching {
  id           String   @id @default(uuid())
  swiperId     String?
  acceptedList Json?
  refusedList  Json?
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model Game {
  id       String   @id @default(uuid())
  gameName String   @unique
  gameLogo String   @unique
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
